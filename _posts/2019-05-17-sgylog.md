---
layout:  post
title: 微地震初至拾取的四个算法实现
subtitle: aic/ltasta/偏振/分形维
date: 2019-05-17
author: zhangzexin
header-img: img/post-bg-unix-linux.jpg
catalog: true
tags:
    - c++
    - c
    - python
---
# STA/LTA
- 长视窗短时窗算法
  
## 理论基础
![img](https://upload.cc/i1/2019/05/17/7RoJMI.jpg)

![img](https://upload.cc/i1/2019/05/17/eopguU.jpg)

![img](https://upload.cc/i1/2019/05/17/R4aiQy.jpg)

![img](https://upload.cc/i1/2019/05/17/hHM0X3.jpg)

## 代码实现
```c++
#include <bits/stdc++.h>
using namespace std;

struct SegyReelHdrStruct
{
    char comment[3200];
    long int jobid;
    long int lino;
    long int reno;
    short int ntrpr;
    short int nart;
    short int hdt;
    short int dto;
    short int hns;
    short int nso;
    short int format;
    short int fold; /* CDP fold expected per CDP ensemble */
    short int tsort;
    short int vscode;      
    short int hsfs;        /* sweep frequency at start */
    short int hsfe;        /* sweep frequency at end */
    short int hslen;       /* sweep length (ms) */
    short int hstyp;       
    short int schn;        /* trace number of sweep channel */
    short int hstas;       
    short int hstae;       
    short int htatyp;      
    short int hcorr;       /* correlated data traces code:1 = no 2 = yes */
    short int bgrcv;       /* binary gain recovered code: 1 = yes 2 = no */
    short int rcvm;        
    short int mfeet;       /* measurement system code: 1 = meters 2 = feet */
    short int polyt;       
    short int vpol;        
    short int hunass[170]; /* unassigned */
};                         
struct SegyTraceHdrStruct
{
    long int tracl; /* trace sequence number within line */
    long int tracr; /* trace sequence number within reel */
    long int fldr;  /* field record number */
    long int tracf; /* trace number within field record */
    long int ep;    /* energy source point number */
    long int cdp;   /* CDP ensemble number */
    long int cdpt;  /* trace number within CDP ensemble */
    short int trid;
    short int nvs;   
    short int nhs;   
    short int duse;  /* data use: 1 = production 2 = test */
    long int offset; 
    long int gelev;  
    long int selev;  
    long int sdepth; /* source depth below surface (positive) */
    long int gdel;   /* datum elevation at receiver group */
    long int sdel;   /* datum elevation at source */
    long int swdep;  /* water depth at source */
    long int gwdep;  /* water depth at receiver group */
    short int scalel;
    short int scalco;
    long int sx; /* X source coordinate */
    long int sy; /* Y source coordinate */
    long int gx; /* X group coordinate */
    long int gy; /* Y group coordinate */
    short int counit;
    short int wevel;  /* weathering velocity */
    short int swevel; /* subweathering velocity */
    short int sut;    /* uphole time at source */
    short int gut;    /* uphole time at receiver group */
    short int sstat;  /* source static correction */
    short int gstat;  /* group static correction */
    short int tstat;  /* total static applied */
    short int laga;
    short int lagb;
    short int delrt;
    short int muts;        /* mute time--start */
    short int mute;        /* mute time--end */
    unsigned short int ns; /* number of samples in this trace */
    unsigned short int dt; /* sample interval; in micro-seconds */
    short int gain;
    short int igc;  /* instrument gain constant */
    short int igi;  /* instrument early or initial gain */
    short int corr; /* correlated: 1 = no 2 = yes */
    short int sfs;  /* sweep frequency at start */
    short int sfe;  /* sweep frequency at end */
    short int slen; /* sweep length in ms */
    short int styp;
    short int stas;   /* sweep trace taper length at start in ms */
    short int stae;   /* sweep trace taper length at end in ms */
    short int tatyp;  /* taper type: 1=linear, 2=cos^2, 3=other */
    short int afilf;  /* alias filter frequency if used */
    short int afils;  /* alias filter slope */
    short int nofilf; /* notch filter frequency if used */
    short int nofils; /* notch filter slope */
    short int lcf;    /* low cut frequency if used */
    short int hcf;    /* high cut frequncy if used */
    short int lcs;    /* low cut slope */
    short int hcs;    /* high cut slope */
    short int year;   /* year data recorded */
    short int day;    /* day of year */
    short int hour;   /* hour of day (24 hour clock) */
    short int minute; /* minute of hour */
    short int sec;    /* second of minute */
    short int timbas; /* time basis code:1 = local 2 = GMT 3 = other */
    short int trwf;
    short int grnors; /* geophone group number of roll switch position one */
    short int grnofr;
    short int grnlof;
    short int gaps; /* gap size (total number of groups dropped) */
    short int otrav;
    short int unass[30]; /* unassigned -- for optional info */
};

int main()
{
    FILE *f1, *f2,*f3,*f4,*f5; //定义两个文件指针变量
    int i, l;
    char FileName[200]; //字符数组，存放文件名
    int Traces, Trace_length, Trace2read;
    float *TraceData;
    //printf("输入地震文件名[*.sgy]:");
    //scanf("%s",FileName);
    //当然上面两行，可用一个这样的语句代替：strcpy(FileName,"100.sgy");
    f1 = fopen("./1.sgy", "rb"); //打开文件，打开形式为：二进制读 rb
    if (f1 == NULL)              //判断打开了没有，不成功就返回吧。
    {
        printf("Cannot open input file!\n"); //显示信息
        exit(0);                             //退出
    }
    Trace2read = 430;   // 要读取哪一道，可以键盘输入，为方便在这就给定了，设为第430道
    Trace_length = 800; //一个地震道里面 数据的个数,可以从文件头获得，这里先拿来用了
    Traces = 631;       //该文件地震道的个数，也可以通过文件头里面的信息设法获得，也是先拿来用
    l = 3600L + (240 + Trace_length * 4L) * (Trace2read) + 240;

    fseek(f1, l, 0); //定位到那个地震道的 数据的 开始位置
    TraceData = new float[Trace_length];

    fread(TraceData, 4L * Trace_length, 1, f1);

    fclose(f1);

    f2 = fopen("raw.txt", "w");
    for (i = 0; i < Trace_length; i++)
    {
        fprintf(f2, "%f \n", TraceData[i]);
    }
    fclose(f2);
    


    f3 = fopen("noisy.txt","w+");
    float a;
    for (i = 0; i < Trace_length; i++)
    {
        a = (rand()/(float)(RAND_MAX/2.0e+37))-1.0e+37;
        TraceData[i]+=a;
        fprintf(f3, "%f \n", TraceData[i]);
        printf("%lf \n", TraceData[i]);
    }
    fclose(f3);
    
    f4=fopen("long.txt","w+");
    for(i = 0; i < Trace_length; i++){
        float fa=TraceData[i];
        for(int j=1;j<=7;j++){
            fa=fa+TraceData[i+j];
        }
        fa=fa/8;
        fprintf(f4, "%f \n", fa);
    }
    fclose(f4);

    f5=fopen("short.txt","w+");
    for(i = 0; i < Trace_length; i++){
        float fa=TraceData[i];
        for(int j=1;j<=2;j++){
            fa=fa+TraceData[i+j];
        }
        fa=fa/3;
        fprintf(f5, "%f \n", fa);
    }
    fclose(f5);

    delete TraceData;
    return 0;
}
```

- 绘图

```py
import matplotlib.pyplot as plt
import string

fo1 = open("C:\\Users\\13994\\Documents\\vscode\\c++\\noisy.txt", "r")
fo2 = open("C:\\Users\\13994\\Documents\\vscode\\c++\\long.txt", "r")
fo3 = open("C:\\Users\\13994\\Documents\\vscode\\c++\\short.txt", "r")
str1 = fo1.readlines()
str2 = fo2.readlines()
str3 = fo3.readlines()
cnt = 1
yl1 = [1.0]
yl2 = [1.0]
yl3 = [1.0]
yl4 = []
xl = [1]
for eachline in str1:
    ct1 = float(eachline)
    yl1.append(ct1)
    xl.append(cnt+1)
    cnt = cnt+1

cnt=1
for eachline in str2:
    ct1 = float(eachline)
    yl2.append(ct1)

cnt=1
for eachline in str3:
    ct1 = float(eachline)
    yl3.append(ct1)

for i in range(len(xl)):
    yl4.append(yl3[i]/yl2[i])

print(yl4)
fo1.close()
fo2.close()
fo3.close()
plt.plot(xl,yl1,label='noisy',c='black')
plt.plot(xl,yl2,label='LTA',c='blue')
plt.plot(xl,yl3,label='STA',c='red')
# plt.plot(xl,yl4,label='STA/LTA',c='green')
plt.xlabel('time(ms)')
plt.ylabel('Aplitude') 
plt.title('STA && LTA')
plt.legend()
plt.show()

```

# AIC算法

## 理论基础
![img](https://upload.cc/i1/2019/05/17/3QGIMz.jpg)

![img](https://upload.cc/i1/2019/05/17/2vYsTd.jpg)

## 代码实现

```c
#include <bits/stdc++.h>
using namespace std;

struct Data{
    double x;
    double y;
    double z;
    double ak;

};
double var1(double Mx,int start,int end,double x){
    double ans=0;
    for(int i=start;i<=end;i++){
        ans+=pow((x-Mx),2);
    }
    return ans;
}
int main(){
    Data data1[15010];
    
    // 开始读取  
    ifstream in("outxyz.txt");  
    string filename;  
    string line; 
    int cnt=0;
    double tmp;
    if(in){  
        while (getline (in, line)){   
            cnt++;
            stringstream ss;
            ss << line;
            ss >> tmp;
            if(cnt%3==1){
                tmp=tmp*10000;
                data1[cnt/3].x=tmp;
            }else if(cnt%3==2){
                tmp=tmp*10000;
                data1[cnt/3].y=tmp;
            }else{
                tmp=tmp*10000;
                data1[cnt/3].z=tmp;
            }
        }  
    }  
    else{  cout <<"no such file" << endl;  }  
    // 读取结束

    //AIC算法
    double Mx=0,My=0,Mz=0;
    for(int i=0;i<=14999;i++){
        Mx+=data1[i].x;
    }
    Mx=Mx/15000;
    for(int i=0;i<=14999;i++){
        double tmp3=0;
        tmp3+=(i+1)*log10(var1(Mx,1,i+1,data1[i].x));
        tmp3+=(15000-i-2)*log10(var1(Mx,i+2,150000,data1[i].x));
        data1[i].ak=tmp3;
    }
    
    //输出结果
    FILE *f1;
    f1=fopen("aicout.txt","w");
    for(int i=0;i<=14999;i++){
        fprintf(f1,"%llf\n",data1[i].ak);
    }
    fclose(f1);
    //输出结束
    return 0;  
}  
```

- 绘图

```py
import matplotlib.pyplot as plt 
import string
fo1=open("C:\\Users\\13994\\Documents\\vscode\\c++\\aicout.txt", "r")
fo2=open("C:\\Users\\13994\\Documents\\vscode\\c++\\outxyz.txt", "r")

cnt=1
yl1 = [0] #aic曲线
yl2 = [0]
xl = [1]

# 读取aic输出数据
str1 = fo1.readlines()
for eachline in str1:
    ct1 = float(eachline)
    ct1=ct1/400000
    ct1=ct1+0.2
    yl1.append(ct1)
    xl.append(cnt+1)
    cnt = cnt+1

# 读取原数据s
cnt=0
str2 = fo2.readlines()
for eachline in str2:
    ct1 = float(eachline)
    cnt=cnt+1
    if(cnt%3==1):
        ct1=ct1*10000
        yl2.append(ct1)
        #print(ct1)

fo1.close()
fo2.close()

plt.plot(xl,yl1,label='aic',c='red')
plt.plot(xl,yl2,label='raw',c='black')
plt.xlabel('time(ms)')
plt.ylabel('Aplitude') 
plt.title('Meada-AIC')
plt.legend()
plt.show()
```
